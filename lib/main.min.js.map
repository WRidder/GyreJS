{"version":3,"sources":["webpack://gyrejs/webpack/universalModuleDefinition","webpack://gyrejs/webpack/bootstrap","webpack://gyrejs/./src/scheduler.ts","webpack://gyrejs/./src/gyre.ts"],"names":["root","factory","exports","module","define","amd","gyrejs","window","e","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","default","object","property","prototype","hasOwnProperty","p","s","t","Scheduler","[object Object]","this","readyQueue","readyQueueIDlist","Set","timeBudget","projectionData","Map","listeners","listenerCount","projectionId","cb","opts","priority","id","pIds","checkIfValidProjectionId","lsId","set","addIListenerToQueue","pIdsToUnsubscribe","has","filter","x","includes","length","delete","pId","createIDForIQueueItem","splice","ms","data","forEach","listener","scheduleIListener","startTime","getCurrentTime","ranOnce","item","pop","getCallbackById","genFn","ret","next","console","error","done","push","res","qItem","Date","now","queueItem","addItemToQueue","idx","unshift","add","constructor","Array","gyre_Gyre","scheduler","evt","cmd"],"mappings":"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","file":"main.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"gyrejs\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"gyrejs\"] = factory();\n\telse\n\t\troot[\"gyrejs\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","import { IListenerOptions } from './interfaces';\n\ninterface IListener {\n  id: string;\n  pIds: string[];\n  priority: number;\n  cb: (data: any, pId: string) => any;\n}\n\ninterface IQueueItem {\n  pId: string;\n  priority: number;\n  lsId: number;\n  genFn?: Iterator<void>;\n}\n\nexport class Scheduler {\n  private readyQueue: IQueueItem[] = [];\n  private readyQueueIDlist: Set<string> = new Set();\n  private timeBudget: number = 10;\n  private projectionData: Map<string, object> = new Map();\n  private listeners: Map<number, IListener> = new Map();\n  private listenerCount = 1;\n\n  constructor() {}\n\n  register(projectionId: string | string[], cb: (data: any, pId: string) => any,\n           opts: IListenerOptions = { priority: 0, id: 'unnamed' }) {\n    const pIds = Scheduler.checkIfValidProjectionId(projectionId);\n\n    if (typeof cb !== 'function') {\n      throw '[GyreJS] Callback should be a function.';\n    }\n    if (opts.priority < 0 || opts.priority > 99) {\n      throw '[GyreJS] IListener priority should be a number in range of [0,99].';\n    }\n\n    const lsId = this.listenerCount;\n    this.listeners.set(this.listenerCount, {\n      pIds,\n      cb,\n      id: opts.id,\n      priority: opts.priority,\n    });\n\n    this.addIListenerToQueue(lsId);\n    this.listenerCount += 1;\n\n    return lsId;\n  }\n\n  unregister(lsId: number, projectionId?: string[] | string) {\n    const pIdsToUnsubscribe: string[] = Scheduler.checkIfValidProjectionId(projectionId);\n\n    if (this.listeners.has(lsId)) {\n      const listener: IListener = this.listeners.get(lsId);\n\n      // If all projectionIds of the current listener are to un-subscribed, remove completely\n      const remainingPIds = listener.pIds.filter(x => !pIdsToUnsubscribe.includes(x));\n      if (remainingPIds.length === 0) {\n        this.listeners.delete(lsId);\n      }\n\n      // Remove from readyQueue\n      let i = this.readyQueue.length;\n      while (i) {\n        if (pIdsToUnsubscribe.includes(this.readyQueue[i - 1].pId)) {\n          this.readyQueueIDlist.delete(Scheduler.createIDForIQueueItem(this.readyQueue[i - 1]));\n          this.readyQueue.splice(i,1);\n        }\n        i -= 1;\n      }\n    }\n  }\n\n  /**\n   * Comment for method ´setTimeBudget´.\n   * @param ms  Comment for parameter ´target´.\n   */\n  setTimeBudget(this:Scheduler, ms: number): void {\n    this.timeBudget = ms;\n  }\n\n  /**\n   * Comment for method ´getTimeBudget´.\n   */\n  getTimeBudget(this:Scheduler): number {\n    return this.timeBudget;\n  }\n\n  projectionUpdate(id: string, data: object) {\n    this.projectionData.set(id, data);\n\n    // Iterate over listeners\n    this.listeners.forEach((listener, lsId) => {\n      if (listener.pIds.includes(id)) {\n        this.scheduleIListener(lsId, id);\n      }\n    });\n  }\n\n  /**\n   * Iterates the ready queue\n   */\n  runOnce() {\n    const startTime = Scheduler.getCurrentTime();\n    let ranOnce = false;\n\n    while ((Scheduler.getCurrentTime() < (startTime + this.timeBudget) ||\n      !ranOnce) && this.readyQueue.length > 0) {\n\n      // Get work item\n      const item = this.readyQueue.pop();\n      const cb = this.getCallbackById(item.lsId);\n      if (!cb) {\n        continue;\n      }\n\n      // If the item has been called before and the callback is a generator, invoke the generator again.\n      if (item.genFn) {\n        let ret;\n        try {\n          ret = item.genFn.next();\n        } catch (e) {\n          console.error(`[GyreJS] Error invoking listener (id: ${item.lsId}) for projection ${item.pId}: `, e);\n        }\n        if (!ret.done) {\n          this.readyQueue.push(item);\n        }\n        continue;\n      }\n\n      // Invoke callback\n      let res;\n      try {\n        res = cb(this.projectionData.get(item.pId), item.pId);\n      } catch (e) {\n        console.error(`[GyreJS] Error invoking listener (id: ${item.lsId}) for projection ${item.pId}: `, e);\n      }\n\n      // Check if it is a generator function\n      if (res && res.next) {\n        const ret = res.next();\n\n        if (!ret.done) {\n          item.genFn = res;\n          this.readyQueue.push(item);\n        }\n      }\n      ranOnce = true;\n    }\n\n    // Check if we ran out of budget. If so, increment priorities to prevent starvation.\n    // However, priorities above 89 are fixed.\n    if (this.readyQueue.length) {\n      this.readyQueue.forEach((qItem) => {\n        qItem.priority += qItem.priority < 89 ? 1 : 0;\n      });\n    }\n  }\n\n  /**\n   * Returns timestamp in milliseconds.\n   */\n  private static getCurrentTime(): number {\n    return Date.now();\n  }\n\n  private getCallbackById(lsId: number): Function | null {\n    const listener = this.listeners.get(lsId);\n    if (listener) {\n      return listener.cb;\n    }\n    return null;\n  }\n\n  private addIListenerToQueue(lsId: number) {\n    const listener = this.listeners.get(lsId);\n\n    listener.pIds.forEach((pId) => {\n      if (this.projectionData.has(pId)) {\n        this.scheduleIListener(lsId, pId);\n      }\n    });\n  }\n\n  private scheduleIListener(lsId: number, pId: string) {\n    const listener = this.listeners.get(lsId);\n\n    if (listener) {\n      const queueItem = {\n        pId,\n        lsId,\n        priority: listener.priority,\n      };\n\n      // Check if not already in queue\n      if (this.readyQueueIDlist.has(Scheduler.createIDForIQueueItem(queueItem))) {\n        return;\n      }\n\n      let i = this.readyQueue.length;\n      if (i === 0 || listener.priority > this.readyQueue[i - 1].priority) {\n        this.addItemToQueue(queueItem, i);\n      } else if (this.readyQueue[0].priority > listener.priority) {\n        this.addItemToQueue(queueItem, 0);\n      } else {\n        do {\n          i = i - 1;\n          if (this.readyQueue[i].priority <= listener.priority) {\n            this.addItemToQueue(queueItem, i + 1);\n            break;\n          }\n        } while (i);\n      }\n    }\n  }\n\n  private addItemToQueue(qItem: IQueueItem, idx: number): void {\n    if (idx === 0) {\n      this.readyQueue.unshift(qItem);\n    } else if (idx === this.readyQueue.length) {\n      this.readyQueue.push(qItem);\n    } else {\n      this.readyQueue.splice(idx, 0, qItem);\n    }\n    this.readyQueueIDlist.add(Scheduler.createIDForIQueueItem(qItem));\n  }\n\n  private static createIDForIQueueItem(qItem: IQueueItem): string {\n    return qItem.lsId + '-' + qItem.pId;\n  }\n\n  private static checkIfValidProjectionId(projectionId: string | string[]): string[] {\n    // Input checking\n    if (typeof projectionId !== 'string' && projectionId.constructor !== Array) {\n      throw 'ProjectionId should be a(n array of) string(s) with non-zero length.';\n    }\n    if (typeof projectionId === 'string' && projectionId.length === 0) {\n      throw 'ProjectionId should be a(n array of) string(s) with non-zero length.';\n    }\n    if (typeof projectionId !== 'string') {\n      projectionId.forEach((pId) => {\n        if (typeof pId !== 'string' || pId.length === 0) {\n          throw 'ProjectionId should be a(n array of) string(s) with non-zero length.';\n        }\n      });\n    }\n\n    return (typeof projectionId === 'string') ? [projectionId] : projectionId;\n  }\n}\n","import { IGyreCommand, IGyreEvent, IGyreOptions } from './interfaces';\nimport { Scheduler } from './scheduler';\n\nexport class Gyre {\n  scheduler = new Scheduler();\n\n  constructor() {}\n\n  start(opts: IGyreOptions= {}) {\n\n  }\n\n  trigger(evt: IGyreEvent) {\n\n  }\n\n  issue(cmd: IGyreCommand) {\n\n  }\n\n  private startWorkers() {\n\n  }\n}\n"],"sourceRoot":""}