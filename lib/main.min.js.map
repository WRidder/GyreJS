{"version":3,"sources":["webpack://gyrejs-[name]/webpack/universalModuleDefinition","webpack://gyrejs-[name]/webpack/bootstrap","webpack://gyrejs-[name]/./src/scheduler.ts","webpack://gyrejs-[name]/./src/gyre.ts"],"names":["root","factory","exports","module","define","amd","window","e","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","default","object","property","prototype","hasOwnProperty","p","s","t","Scheduler","[object Object]","this","readyQueue","readyQueueIDlist","Set","timeBudget","projectionData","Map","listeners","listenerCount","pIds","cb","opts","priority","id","lsId","set","addIListenerToQueue","pIdsToUnsubscribe","has","filter","x","indexOf","length","delete","pId","createIDForIQueueItem","splice","ms","data","forEach","listener","scheduleIListener","startTime","getCurrentTime","ranOnce","item","pop","getCallbackById","genFn","ret","next","console","error","done","push","res","qItem","Date","now","queueItem","addItemToQueue","idx","unshift","add","gyre_Gyre","scheduler","startWorker","workerScriptPath","bWorker","postMessage","type","projectionId","checkIfValidProjectionId","register","trigger","bind","issue","unregister","path","Worker","onmessage","projectionUpdate","msg","constructor","Array"],"mappings":"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","file":"main.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"gyrejs-main\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"gyrejs-main\"] = factory();\n\telse\n\t\troot[\"gyrejs-main\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","import { IListenerOptions, IListener, IListenerGenerator } from './interfaces';\n\ninterface IListenerItem {\n  id: string;\n  pIds: string[];\n  priority: number;\n  cb: (data: any, pId: string) => any;\n}\n\ninterface IQueueItem {\n  pId: string;\n  priority: number;\n  lsId: number;\n  genFn?: Iterator<void>;\n}\n\nexport class Scheduler {\n  private readyQueue: IQueueItem[] = [];\n  private readyQueueIDlist: Set<string> = new Set();\n  private timeBudget: number = 10;\n  private projectionData: Map<string, object> = new Map();\n  private listeners: Map<number, IListenerItem> = new Map();\n  private listenerCount = 1;\n\n  constructor() {}\n\n  register(pIds: string[], cb: (data: any, pId: string) => any,\n           opts: IListenerOptions = { priority: 0, id: 'unnamed' }) {\n    const lsId = this.listenerCount;\n    this.listeners.set(this.listenerCount, {\n      cb,\n      pIds,\n      id: opts.id,\n      priority: opts.priority,\n    });\n\n    this.addIListenerToQueue(lsId);\n    this.listenerCount += 1;\n\n    return lsId;\n  }\n\n  unregister(lsId: number, pIdsToUnsubscribe: string[] = []) {\n    if (this.listeners.has(lsId)) {\n      const listener: IListenerItem = this.listeners.get(lsId);\n\n      // If all projectionIds of the current listener are to un-subscribed, remove completely\n      const remainingPIds = listener.pIds.filter(x => !(pIdsToUnsubscribe.indexOf(x) > -1));\n      if (remainingPIds.length === 0) {\n        this.listeners.delete(lsId);\n      }\n\n      // Remove from readyQueue\n      let i = this.readyQueue.length;\n      while (i) {\n        if (pIdsToUnsubscribe.indexOf(this.readyQueue[i - 1].pId) > -1) {\n          this.readyQueueIDlist.delete(Scheduler.createIDForIQueueItem(this.readyQueue[i - 1]));\n          this.readyQueue.splice(i,1);\n        }\n        i -= 1;\n      }\n    }\n  }\n\n  /**\n   * Comment for method ´setTimeBudget´.\n   * @param ms  Comment for parameter ´target´.\n   */\n  setTimeBudget(this:Scheduler, ms: number): void {\n    this.timeBudget = ms;\n  }\n\n  /**\n   * Comment for method ´getTimeBudget´.\n   */\n  getTimeBudget(this:Scheduler): number {\n    return this.timeBudget;\n  }\n\n  projectionUpdate(id: string, data: object) {\n    this.projectionData.set(id, data);\n\n    // Iterate over listeners\n    this.listeners.forEach((listener, lsId) => {\n      if (listener.pIds.indexOf(id) > -1) {\n        this.scheduleIListener(lsId, id);\n      }\n    });\n  }\n\n  /**\n   * Iterates the ready queue\n   */\n  runOnce() {\n    const startTime = Scheduler.getCurrentTime();\n    let ranOnce = false;\n\n    while ((Scheduler.getCurrentTime() < (startTime + this.timeBudget) ||\n      !ranOnce) && this.readyQueue.length > 0) {\n\n      // Get work item\n      const item = this.readyQueue.pop();\n      const cb = this.getCallbackById(item.lsId);\n      if (!cb) {\n        continue;\n      }\n\n      // If the item has been called before and the callback is a generator, invoke the generator again.\n      if (item.genFn) {\n        let ret;\n        try {\n          ret = item.genFn.next();\n        } catch (e) {\n          console.error(\n            `[GyreJS] Error during invocation of listener (id: ${item.lsId}) for projection ${item.pId}: `,\n            e);\n        }\n        if (!ret.done) {\n          this.readyQueue.push(item);\n        }\n        continue;\n      }\n\n      // Invoke callback\n      let res;\n      try {\n        res = cb(this.projectionData.get(item.pId), item.pId);\n      } catch (e) {\n        console.error(\n          `[GyreJS] Error during invocation of listener (id: ${item.lsId}) for projection ${item.pId}: `,\n          e);\n      }\n\n      // Check if it is a generator function\n      // @ts-ignore\n      if (res && res.next) {\n        // @ts-ignore\n        const ret = res.next();\n\n        if (!ret.done) {\n          // @ts-ignore\n          item.genFn = res;\n          this.readyQueue.push(item);\n        }\n      }\n      ranOnce = true;\n    }\n\n    // Check if we ran out of budget. If so, increment priorities to prevent starvation.\n    // However, priorities above 89 are fixed.\n    if (this.readyQueue.length) {\n      this.readyQueue.forEach((qItem) => {\n        qItem.priority += qItem.priority < 89 ? 1 : 0;\n      });\n    }\n  }\n\n  /**\n   * Returns timestamp in milliseconds.\n   */\n  private static getCurrentTime(): number {\n    return Date.now();\n  }\n\n  private getCallbackById(lsId: number): (data: any, pId: string) => void  | GeneratorFunction | null {\n    const listener = this.listeners.get(lsId);\n    if (listener) {\n      return listener.cb;\n    }\n    return null;\n  }\n\n  private addIListenerToQueue(lsId: number) {\n    const listener = this.listeners.get(lsId);\n\n    listener.pIds.forEach((pId) => {\n      if (this.projectionData.has(pId)) {\n        this.scheduleIListener(lsId, pId);\n      }\n    });\n  }\n\n  private scheduleIListener(lsId: number, pId: string) {\n    const listener = this.listeners.get(lsId);\n\n    if (listener) {\n      const queueItem = {\n        pId,\n        lsId,\n        priority: listener.priority,\n      };\n\n      // Check if not already in queue\n      if (this.readyQueueIDlist.has(Scheduler.createIDForIQueueItem(queueItem))) {\n        return;\n      }\n\n      let i = this.readyQueue.length;\n      if (i === 0 || listener.priority > this.readyQueue[i - 1].priority) {\n        this.addItemToQueue(queueItem, i);\n      } else if (this.readyQueue[0].priority > listener.priority) {\n        this.addItemToQueue(queueItem, 0);\n      } else {\n        do {\n          i = i - 1;\n          if (this.readyQueue[i].priority <= listener.priority) {\n            this.addItemToQueue(queueItem, i + 1);\n            break;\n          }\n        } while (i);\n      }\n    }\n  }\n\n  private addItemToQueue(qItem: IQueueItem, idx: number): void {\n    if (idx === 0) {\n      this.readyQueue.unshift(qItem);\n    } else if (idx === this.readyQueue.length) {\n      this.readyQueue.push(qItem);\n    } else {\n      this.readyQueue.splice(idx, 0, qItem);\n    }\n    this.readyQueueIDlist.add(Scheduler.createIDForIQueueItem(qItem));\n  }\n\n  private static createIDForIQueueItem(qItem: IQueueItem): string {\n    return qItem.lsId + '-' + qItem.pId;\n  }\n}\n","import { IGyreCommand, IGyreEvent, IGyreOptions, IECInterface, IListenerOptions, IListener } from './interfaces';\nimport { Scheduler } from './scheduler';\n\ninterface IProjectionMessage {\n  data: {\n    id: string;\n    data: any;\n  };\n}\n\nexport class Gyre {\n  private scheduler = new Scheduler();\n  private bWorker: Worker;\n\n  constructor(opts: IGyreOptions) {\n    this.startWorker(opts.workerScriptPath);\n  }\n\n  trigger({ id, data }: IGyreEvent) {\n    this.bWorker.postMessage({\n      id,\n      data,\n      type: 'event',\n    });\n  }\n\n  issue({ id, data }: IGyreCommand) {\n    this.bWorker.postMessage({\n      id,\n      data,\n      type: 'command',\n    });\n  }\n\n  register (projectionId: string | string[], cb: IListener,\n            opts: IListenerOptions = { priority: 0, id: 'unnamed' }) {\n    const pIds = Gyre.checkIfValidProjectionId(projectionId);\n\n    if (typeof cb !== 'function') {\n      throw '[GyreJS] Callback should be a function.';\n    }\n    if (opts.priority < 0 || opts.priority > 99) {\n      throw '[GyreJS] IListener priority should be a number in range of [0,99].';\n    }\n    if (typeof opts.id !== 'string') {\n      throw '[GyreJS] IListener id should be a string.';\n    }\n\n    // Curry the callback function\n    const ccb = (data: any, pId: string) => {\n      cb(data, pId, this.trigger.bind(this), this.issue.bind(this));\n    };\n    this.scheduler.register(pIds, ccb);\n  }\n\n  unregister (lsId: number, projectionId?: string[] | string) {\n    const pIds = Gyre.checkIfValidProjectionId(projectionId);\n    this.scheduler.unregister(lsId, pIds);\n  }\n\n  private startWorker(path: string) {\n    this.bWorker = new Worker(path);\n\n    // Register callbacks\n    this.bWorker.onmessage = this.projectionUpdate.bind(this);\n  }\n\n  private projectionUpdate(msg: IProjectionMessage) {\n    this.scheduler.projectionUpdate(msg.data.id, msg.data.data);\n  }\n\n  private static checkIfValidProjectionId(projectionId: string | string[]): string[] {\n    // Input checking\n    if (typeof projectionId !== 'string' && projectionId.constructor !== Array) {\n      throw 'ProjectionId should be a(n array of) string(s) with non-zero length.';\n    }\n    if (typeof projectionId === 'string' && projectionId.length === 0) {\n      throw 'ProjectionId should be a(n array of) string(s) with non-zero length.';\n    }\n    if (typeof projectionId !== 'string') {\n      projectionId.forEach((pId) => {\n        if (typeof pId !== 'string' || pId.length === 0) {\n          throw 'ProjectionId should be a(n array of) string(s) with non-zero length.';\n        }\n      });\n    }\n\n    return (typeof projectionId === 'string') ? [projectionId] : projectionId;\n  }\n}\n"],"sourceRoot":""}