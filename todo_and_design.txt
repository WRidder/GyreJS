Overview
============
Main components: Scheduler, Projections, Event Queue, Commands, Events, Tasks
Commands/events: ConfirmOrder / OrderConfirmed

Scheduler
================
Public API:
- [done] Register a listener
-$ Inputs: Projection ID, callback
- [done] Unregister a listener
-$ Inputs: ID and callback
- [done] Run
-- Go over queue

Internals:
- [Done] Limits execution time by comparing with quota
-- Quote provides lower bound since function execution time of single callback is not known beforehand
- [Done] Upon receiving data (which contains certain ID), add listeners for this projection to queue

Misc:
- [Done] Could allow for cooperative scheduling (yielding), maybe use ES2015 yield?
- [Done] Listener maybe subscribe to multiple projections?
- [Done] Use pop instead of shift to get items from queue, it's usually much faster (does not require reindexing)
- [Done] How to deal with starvation? I.e. increment priority of remaining items in queue.
- [Done] Compensate for desired fps. Even if timeslot is 10ms, if time since last update is too long for FPS, reduce timeslot.

To fix:
- [Done] Prevent adding same listener for a projection in queue more than once

Assumptions:
- Scheduler is only top-level function in renderer thread
-- Deals with 'view only' libraries like react.
- Any events, like click handlers, should be seen as interrupt handlers, and their execution as short as possible.

ECManager
=========
- [Done] Add timed events and commands using setInterval
- [Done] Support chained projections
- Only push projections which have active listeners
-- lazy update projections which have no active listeners? (i.e. return data asap to main thread)
--- keep a map of projections (ids) and amount of listeners?
--- Might not be needed, maybe only event if projection is listened to at all. Can be determined by gyre.
- Publish projection update at fixed interval.

TaskManager
===========
-- For tasks, could use multiple workers. Use 'affinity' (modulo #workers?) to distribute.

Terminology
=============
- Projection: data structure formed from events
- Event
- Scheduler
- Listener: Subscribed through scheduler using some ID
- Task
-- Only outputs events
- Deterministic barrier
-- Projections only form by events, so replaying events results in the same projections
-- Projections do not have any side effects (pure)
-- The view (browser) should only depend on current state of all projections.
- A task is RUN, an event is TRIGGERED, a command is ISSUED.

Considerations / design decisions
==============
- Do new registered listeners get a copy of current state, or only after update (chose to retain copy)
-- If no, data can be kept in worker only
-- If yes, the scheduler should probably keep copy of latest state of projection..
--- Means data duplication, this is a downside.
-- Can also notify worker to sent data and only update new registered listeners
- ShouldUpdate functions are probably important
- Add possibility for hooks, i.e. for (de)serialization (for example if you want to use ImmutableJS)
- Cannot use sharedworkers due to Safari not supporting it.
- Support chained projections to tailor data as much as possible for views. Keep projection updates as small as possible.
-- Serialization should stay < ~ 10ms.

Possible future features (only if a real need exists)
========================
- Chaining projections
- Save / reload projection states for session resume

Tools
===============
Proper tooling is the most important part and has a front-row seat in this project.
- Monitor (debugging and tracing application)
-- Support custom events which can be used to trace function execution
-- Allow show diff of each projection as result from event
--- https://github.com/zgrossbart/jdd
-- Can show size of projection to be exported to main thread by serializing it in debug mode


Inspiration
========================
- Business logic
-- https://medium.com/@jeffbski/where-do-i-put-my-business-logic-in-a-react-redux-application-9253ef91ce1

Documentation
=============
- User doc
-- OVerview of where does business logic go (in commands (for validation)/projections), etc
- Developer doc
- [Done] Coverage report

Child extensions
================
Sensible hooks
- I.e. returns a gyre with some sensible default hooks
-- an Immutable hook for data to listeners and commands (https://stackoverflow.com/questions/16064136/create-a-read-only-immutable-copy-of-any-object-including-deep-properties)

Demos
======
- A page with 100 updating graphs
-- show difference single-threaded and multi-threaded version. So, 2 different pages.
- Reddit viewer
- have examples on codesandbox or codepen

Production use notes
====================
Make separate bundles for (if want to use multithreading):
- render thread
- projection / command handler thread
- Task thread
Html API required:
- Worker (if you want to use the multithreading functionality)


Code layout
============
- [Done] Maybe put all interfaces in dedicated file?
-- [Done] Export only public interfaces, i.e. for listeners, events, commands, etc
- Input verification only in main Gyre object

Public release of lib
=====================
- Squash commit history
- Distribution methods (look at VueJS)
-- See: https://nolanlawson.com/2015/10/19/the-struggles-of-publishing-a-javascript-library/
-- web compatible format (UMD, AMD,â€¦) in ./dist
-- S5 compiled source in lib (keeping the file structure of src)
-- cdn (jsDelivr / cdnjs)
- Coverage report

USPs
====
- No dependencies
- Supports multithreading
- Fully tested (100% coverage?)
- Typescript support (also comes with the types)

Best practices
==============
- Use many projections, can use chained projections. Try to get data layout to be as optimal for views.

Monetization
============
- Patreon, books, videos, donations, debugging website.
- If large sum: able to hire someone to do SLA.
