Overview
============
Main components: Scheduler, Projections, Event Queue, Commands, Events, Tasks
Commands/events: ConfirmOrder / OrderConfirmed

Scheduler
================
Public API:
- [done] Register a listener
-$ Inputs: Projection ID, callback
- [done] Unregister a listener
-$ Inputs: ID and callback
- [done] Run
-- Go over queue

Internals:
- [Done] Limits execution time by comparing with quota
-- Quote provides lower bound since function execution time of single callback is not known beforehand
- [Done] Upon receiving data (which contains certain ID), add listeners for this projection to queue

Misc:
- [Done] Could allow for cooperative scheduling (yielding), maybe use ES2015 yield?
- Use both for render side as well as for tasks
-- For tasks, could use multiple workers. Use 'affinity' (modulo #workers?) to distribute.
-- TaskScheduler and RenderScheduler
- [Done] Listener maybe subscribe to multiple projections?
- [Done] Use pop instead of shift to get items from queue, it's usually much faster (does not require reindexing)
- [Done] How to deal with starvation? I.e. increment priority of remaining items in queue.

To fix:
- [Done] Prevent adding same listener for a projection in queue more than once

Assumptions:
- Scheduler is only top-level function in renderer thread
- Any events, like click handlers, should be seen as interrupt handlers, and their execution as short as possible.

ECManager
=========
- Add timed events and commands using setInterval

Terminology
=============
- Projection: data structure formed from events
- Event
- Scheduler
- Listener: Subscribed through scheduler using some ID
- Task
-- Only outputs events
- Deterministic barrier
-- Projections only form by events, so replaying events results in the same projections
-- Projections do not have any side effects (pure)
-- The view (browser) should only depend on current state of all projections.
- A task is RUN, an event is TRIGGERED, a command is ISSUED.

Considerations
==============
- Do new registered listeners get a copy of current state, or only after update (chose to retain copy)
-- If no, data can be kept in worker only
-- If yes, the scheduler should probably keep copy of latest state of projection..
--- Means data duplication, this is a downside.
- ShouldUpdate functions are probably important
- Add possibility for hooks, i.e. for (de)serialization (for example if you want to use ImmutableJS)

Possible future features (only if a real need exists)
========================
- Chaining projections
- Save / reload projection states for session resume

Tools
===============
Proper tooling is the most important part and has a front-row seat in this project.
- Monitor (debugging and tracing application)
-- Support custom events which can be used to trace function execution
-- Allow show diff of each projection as result from event
--- https://github.com/zgrossbart/jdd

Inspiration
========================
- Business logic
-- https://medium.com/@jeffbski/where-do-i-put-my-business-logic-in-a-react-redux-application-9253ef91ce1

Documentation
=============
- User doc
-- OVerview of where does business logic go (in commands (for validation)/projections), etc
- Developer doc

Child extensions
================
Sensible hooks
- I.e. returns a gyre with some sensible default hooks
-- an Immutable hook for data to listeners and commands (https://stackoverflow.com/questions/16064136/create-a-read-only-immutable-copy-of-any-object-including-deep-properties)

Demos
======
- A page with 100 updating graphs
-- show difference single-threaded and multi-threaded version. So, 2 different pages.
- Reddit viewer

Production use notes
====================
Make separate bundles for (if want to use multithreading):
- render thread
- projection / command handler thread
- Task thread

Code layout
============
- [Done] Maybe put all interfaces in dedicated file?
-- Export only public interfaces, i.e. for listeners, events, commands, etc

Public release of lib
=====================
- Squash commit history

USPs
====
- No dependencies
- Supports multithreading
- Fully tested (100% coverage?)
- Typescript support (also comes with the types)
