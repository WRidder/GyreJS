Overview
============
Main components: Scheduler, Projections, Event Queue, Commands, Events, Tasks
Commands/events: ConfirmOrder / OrderConfirmed


GyreJs general functionality
============================
- Provide hooks, e.g. for serialization.

To investigate / check / trace
======================
- How webworker messages are queued by event loop.

Scheduler
================
Public API:
- [done] Register a listener
-$ Inputs: Projection ID, callback
- [done] Unregister a listener
-$ Inputs: ID and callback
- [done] Run
-- Go over queue

Internals:
- [Done] Limits execution time by comparing with quota
-- Quote provides lower bound since function execution time of single callback is not known beforehand
- [Done] Upon receiving data (which contains certain ID), add listeners for this projection to queue

Misc:
- [Done] Could allow for cooperative scheduling (yielding), maybe use ES2015 yield?
- [Done] Listener maybe subscribe to multiple projections?
- [Done] Use pop instead of shift to get items from queue, it's usually much faster (does not require reindexing)
- [Done] How to deal with starvation? I.e. increment priority of remaining items in queue.
- [Done] Compensate for desired fps. Even if timeslot is 10ms, if time since last update is too long for FPS, reduce timeslot.
- Batch commands/events being send to ECManager
-- Send at end of listener update cycle
-

To fix:
- [Done] Prevent adding same listener for a projection in queue more than once

Assumptions:
- Scheduler is only top-level function in renderer thread
-- Deals with 'view only' libraries like react.
- Any events, like click handlers, should be seen as interrupt handlers, and their execution as short as possible.

ECManager
=========
- [Done] Add timed events and commands using setInterval
- [Done] Support chained projections
- Only push projections which have active listeners
-- lazy update projections which have no active listeners? (i.e. return data asap to main thread)
--- keep a map of projections (ids) and amount of listeners?
--- Might not be needed, maybe only event if projection is listened to at all. Can be determined by gyre.
- [Done] Publish projection update at fixed interval.
- Option to set minimal interval between updates for a given projection.

TaskManager
===========
-- For tasks, could use multiple workers. Use 'affinity' (modulo #workers?) to distribute.
- Task probably needs an initialization function. E.g. for threejs, create all the objects.

Terminology
=============
- Projection: data structure formed from events
- Event
- Scheduler
- Listener: Subscribed through scheduler using some ID
- Task
-- Only outputs events
- Deterministic barrier
-- Projections only form by events, so replaying events results in the same projections
-- Projections do not have any side effects (pure)
-- The view (browser) should only depend on current state of all projections.
- A task is RUN, an event is TRIGGERED, a command is ISSUED.

Considerations / design decisions
==============
- Do new registered listeners get a copy of current state, or only after update (chose to retain copy)
-- If no, data can be kept in worker only
-- If yes, the scheduler should probably keep copy of latest state of projection..
--- Means data duplication, this is a downside.
-- Can also notify worker to sent data and only update new registered listeners
- ShouldUpdate functions are probably important
- Add possibility for hooks, i.e. for (de)serialization (for example if you want to use ImmutableJS)
- Cannot use sharedworkers due to Safari not supporting it.
- Support chained projections to tailor data as much as possible for views. Keep projection updates as small as possible.
-- Serialization should stay < ~ 10ms.
- High precision timing is problematic due to the newly implemented mitigations against spectre/meltdown attacks.
-- Precision of performance.now and date.gettime is ~2ms in firefox. 100us + 100us jitter in chrome/IE.

Possible future features (only if a real need exists)
========================
- Chaining projections
- Save / reload projection states for session resume

Tools
===============
Proper tooling is the most important part and has a front-row seat in this project.
- Monitor (debugging and tracing application)
-- Support custom events which can be used to trace function execution
-- Allow show diff of each projection as result from event
--- https://github.com/zgrossbart/jdd
-- Can show size of projection to be exported to main thread by serializing it in debug mode
-- Projection stats
--- data size
--- time taken for transmission (record timestamp on send and receive)
--- (number of) events reacted to
--- number of (indirect) listeners / chained projections

-- Stats page
--- numbers: nr of received evts/cmds, total data size,
--- graphs: (#evts/cmds, transmitted and received data size, listeners.

- For tracing
-- Listener invocation
--- to track: time, errors
--- Add support for Gyre.trace() function (only in dev mode?)
---- Can track in which listener itś called, due to either timestamp or keeping a counter (ts probably not precise enough)
-- command / events send to ECmanager, also size.
--- seralization time

- Warnings / checks
-- If commandhandlers or chaned projections change the parent / source state.
-- Time overrides

- Enable / disable detailed reporting (or itś just trace mode which you can enable)

- for charts, use: https://vx-demo.now.sh/
- ui lib: semantic ui react + semantic theme.
- i18n: https://github.com/airbnb/polyglot.js
- Create chrome/firefox extensions.

Inspiration
========================
- Business logic
-- https://medium.com/@jeffbski/where-do-i-put-my-business-logic-in-a-react-redux-application-9253ef91ce1

Documentation
=============
- User doc
-- OVerview of where does business logic go (in commands (for validation)/projections), etc
- Developer doc
- [Done] Coverage report

Child extensions
================
Sensible hooks
- I.e. returns a gyre with some sensible default hooks
-- an Immutable hook for data to listeners and commands (https://stackoverflow.com/questions/16064136/create-a-read-only-immutable-copy-of-any-object-including-deep-properties)

Demos
======
- A page with 100 updating graphs
-- Could react to mouse movement for example, or scroll location. Which udpates the data.
-- show difference single-threaded and multi-threaded version. So, 2 different pages.
- Reddit viewer
- have examples on codesandbox or codepen
- WebGL 3D demo
-- https://github.com/lo-th/Oimo.js/ (physics) + threejs
-- oimo can run in a task, e.g. using setinterval

Examples
- View libraries: react, vue, riot.js, preact

Production use notes
====================
Make separate bundles for (if want to use multithreading):
- render thread
- projection / command handler thread
- Task thread
Html API required:
- Worker (if you want to use the multithreading functionality)


Code layout
============
- [Done] Maybe put all interfaces in dedicated file?
-- [Done] Export only public interfaces, i.e. for listeners, events, commands, etc
- Input verification only in main Gyre object

Public release of lib
=====================
- Squash commit history
- Distribution methods (look at VueJS)
-- See: https://nolanlawson.com/2015/10/19/the-struggles-of-publishing-a-javascript-library/
-- web compatible format (UMD, AMD,…) in ./dist
-- S5 compiled source in lib (keeping the file structure of src)
-- cdn (jsDelivr / cdnjs)
- Coverage report

Support libs
=============
- gyrejs-router (very simple router solution)
-- react-gyrejs-router (sort of copy of: https://github.com/reactjs/react-router-redux)
-- vue-gyrejs-router (mimic functionality of vue router?)

USPs
====
- No dependencies
- Supports multithreading
- Fully tested (100% coverage?)
- Typescript support (also comes with the types)
- minimal surface API (it just works)

Best practices
==============
- Use many projections, can use chained projections. Try to get data layout to be as optimal for views.
- State in projections should be serializable.

Monetization
============
- Patreon, books, videos, donations, debugging website.
- If large sum: able to hire someone to do SLA.
